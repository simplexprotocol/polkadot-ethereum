package substrate

import (
	"github.com/simplexprotocol/go-substrate-rpc-client/types"
)

var MetadataExemplary = &types.Metadata{MagicNumber: 0x6174656d, Version: 0xb, IsMetadataV4: false, AsMetadataV4: types.MetadataV4{Modules: []types.ModuleMetadataV4(nil)}, IsMetadataV7: false, AsMetadataV7: types.MetadataV7{Modules: []types.ModuleMetadataV7(nil)}, IsMetadataV8: false, AsMetadataV8: types.MetadataV8{Modules: []types.ModuleMetadataV8(nil)}, IsMetadataV9: false, AsMetadataV9: types.MetadataV9{Modules: []types.ModuleMetadataV8(nil)}, IsMetadataV10: false, AsMetadataV10: types.MetadataV10{Modules: []types.ModuleMetadataV10(nil)}, IsMetadataV11: true, AsMetadataV11: types.MetadataV11{MetadataV10: types.MetadataV10{Modules: []types.ModuleMetadataV10{types.ModuleMetadataV10{Name: "System", HasStorage: true, Storage: types.StorageMetadataV10{Prefix: "System", Items: []types.StorageFunctionMetadataV10{types.StorageFunctionMetadataV10{Name: "Account", Modifier: types.StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: types.StorageFunctionTypeV10{IsType: false, AsType: "", IsMap: true, AsMap: types.MapTypeV10{Hasher: types.StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: true, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "T::AccountId", Value: "AccountInfo<T::Index, T::AccountData>", Linked: false}, IsDoubleMap: false, AsDoubleMap: types.DoubleMapTypeV10{Hasher: types.StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: types.StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: types.Bytes{0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}, Documentation: []types.Text{" The full account information for a particular account ID."}}, types.StorageFunctionMetadataV10{Name: "ExtrinsicCount", Modifier: types.StorageFunctionModifierV0{IsOptional: true, IsDefault: false, IsRequired: false}, Type: types.StorageFunctionTypeV10{IsType: true, AsType: "u32", IsMap: false, AsMap: types.MapTypeV10{Hasher: types.StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: types.DoubleMapTypeV10{Hasher: types.StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: types.StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: types.Bytes{0x0}, Documentation: []types.Text{" Total extrinsics count for the current block."}}, types.StorageFunctionMetadataV10{Name: "BlockWeight", Modifier: types.StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: types.StorageFunctionTypeV10{IsType: true, AsType: "weights::ExtrinsicsWeight", IsMap: false, AsMap: types.MapTypeV10{Hasher: types.StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: types.DoubleMapTypeV10{Hasher: types.StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: types.StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: types.Bytes{0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}, Documentation: []types.Text{" The current weight for the block."}}, types.StorageFunctionMetadataV10{Name: "AllExtrinsicsLen", Modifier: types.StorageFunctionModifierV0{IsOptional: true, IsDefault: false, IsRequired: false}, Type: types.StorageFunctionTypeV10{IsType: true, AsType: "u32", IsMap: false, AsMap: types.MapTypeV10{Hasher: types.StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: types.DoubleMapTypeV10{Hasher: types.StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: types.StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: types.Bytes{0x0}, Documentation: []types.Text{" Total length (in bytes) for all extrinsics put together, for the current block."}}, types.StorageFunctionMetadataV10{Name: "BlockHash", Modifier: types.StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: types.StorageFunctionTypeV10{IsType: false, AsType: "", IsMap: true, AsMap: types.MapTypeV10{Hasher: types.StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: true}, Key: "T::BlockNumber", Value: "T::Hash", Linked: false}, IsDoubleMap: false, AsDoubleMap: types.DoubleMapTypeV10{Hasher: types.StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: types.StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: types.Bytes{0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}, Documentation: []types.Text{" Map of block numbers to block hashes."}}, types.StorageFunctionMetadataV10{Name: "ExtrinsicData", Modifier: types.StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: types.StorageFunctionTypeV10{IsType: false, AsType: "", IsMap: true, AsMap: types.MapTypeV10{Hasher: types.StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: true}, Key: "u32", Value: "Vec<u8>", Linked: false}, IsDoubleMap: false, AsDoubleMap: types.DoubleMapTypeV10{Hasher: types.StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: types.StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: types.Bytes{0x0}, Documentation: []types.Text{" Extrinsics data for the current block (maps an extrinsic's index to its data)."}}, types.StorageFunctionMetadataV10{Name: "Number", Modifier: types.StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: types.StorageFunctionTypeV10{IsType: true, AsType: "T::BlockNumber", IsMap: false, AsMap: types.MapTypeV10{Hasher: types.StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: types.DoubleMapTypeV10{Hasher: types.StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: types.StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: types.Bytes{0x0, 0x0, 0x0, 0x0}, Documentation: []types.Text{" The current block number being processed. Set by `execute_block`."}}, types.StorageFunctionMetadataV10{Name: "ParentHash", Modifier: types.StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: types.StorageFunctionTypeV10{IsType: true, AsType: "T::Hash", IsMap: false, AsMap: types.MapTypeV10{Hasher: types.StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: types.DoubleMapTypeV10{Hasher: types.StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: types.StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: types.Bytes{0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}, Documentation: []types.Text{" Hash of the previous block."}}, types.StorageFunctionMetadataV10{Name: "ExtrinsicsRoot", Modifier: types.StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: types.StorageFunctionTypeV10{IsType: true, AsType: "T::Hash", IsMap: false, AsMap: types.MapTypeV10{Hasher: types.StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: types.DoubleMapTypeV10{Hasher: types.StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: types.StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: types.Bytes{0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}, Documentation: []types.Text{" Extrinsics root of the current block, also part of the block header."}}, types.StorageFunctionMetadataV10{Name: "Digest", Modifier: types.StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: types.StorageFunctionTypeV10{IsType: true, AsType: "DigestOf<T>", IsMap: false, AsMap: types.MapTypeV10{Hasher: types.StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: types.DoubleMapTypeV10{Hasher: types.StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: types.StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: types.Bytes{0x0}, Documentation: []types.Text{" Digest of the current block, also part of the block header."}}, types.StorageFunctionMetadataV10{Name: "Events", Modifier: types.StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: types.StorageFunctionTypeV10{IsType: true, AsType: "Vec<EventRecord<T::Event, T::Hash>>", IsMap: false, AsMap: types.MapTypeV10{Hasher: types.StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: types.DoubleMapTypeV10{Hasher: types.StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: types.StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: types.Bytes{0x0}, Documentation: []types.Text{" Events deposited for the current block."}}, types.StorageFunctionMetadataV10{Name: "EventCount", Modifier: types.StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: types.StorageFunctionTypeV10{IsType: true, AsType: "EventIndex", IsMap: false, AsMap: types.MapTypeV10{Hasher: types.StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: types.DoubleMapTypeV10{Hasher: types.StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: types.StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: types.Bytes{0x0, 0x0, 0x0, 0x0}, Documentation: []types.Text{" The number of events in the `Events<T>` list."}}, types.StorageFunctionMetadataV10{Name: "EventTopics", Modifier: types.StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: types.StorageFunctionTypeV10{IsType: false, AsType: "", IsMap: true, AsMap: types.MapTypeV10{Hasher: types.StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: true, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "T::Hash", Value: "Vec<(T::BlockNumber, EventIndex)>", Linked: false}, IsDoubleMap: false, AsDoubleMap: types.DoubleMapTypeV10{Hasher: types.StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: types.StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: types.Bytes{0x0}, Documentation: []types.Text{" Mapping between a topic (represented by T::Hash) and a vector of indexes", " of events in the `<Events<T>>` list.", "", " All topic vectors have deterministic storage locations depending on the topic. This", " allows light-clients to leverage the changes trie storage tracking mechanism and", " in case of changes fetch the list of events of interest.", "", " The value has the type `(T::BlockNumber, EventIndex)` because if we used only just", " the `EventIndex` then in case if the topic has the same contents on the next block", " no notification will be triggered thus the event might be lost."}}, types.StorageFunctionMetadataV10{Name: "LastRuntimeUpgrade", Modifier: types.StorageFunctionModifierV0{IsOptional: true, IsDefault: false, IsRequired: false}, Type: types.StorageFunctionTypeV10{IsType: true, AsType: "LastRuntimeUpgradeInfo", IsMap: false, AsMap: types.MapTypeV10{Hasher: types.StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: types.DoubleMapTypeV10{Hasher: types.StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: types.StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: types.Bytes{0x0}, Documentation: []types.Text{" Stores the `spec_version` and `spec_name` of when the last runtime upgrade happened."}}, types.StorageFunctionMetadataV10{Name: "ExecutionPhase", Modifier: types.StorageFunctionModifierV0{IsOptional: true, IsDefault: false, IsRequired: false}, Type: types.StorageFunctionTypeV10{IsType: true, AsType: "Phase", IsMap: false, AsMap: types.MapTypeV10{Hasher: types.StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: types.DoubleMapTypeV10{Hasher: types.StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: types.StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: types.Bytes{0x0}, Documentation: []types.Text{" The execution phase of the block."}}}}, HasCalls: true, Calls: []types.FunctionMetadataV4{types.FunctionMetadataV4{Name: "fill_block", Args: []types.FunctionArgumentMetadata{types.FunctionArgumentMetadata{Name: "_ratio", Type: "Perbill"}}, Documentation: []types.Text{" A dispatch that will fill the block weight up to the given ratio."}}, types.FunctionMetadataV4{Name: "remark", Args: []types.FunctionArgumentMetadata{types.FunctionArgumentMetadata{Name: "_remark", Type: "Vec<u8>"}}, Documentation: []types.Text{" Make some on-chain remark.", "", " # <weight>", " - `O(1)`", " - Base Weight: 0.665 µs, independent of remark length.", " - No DB operations.", " # </weight>"}}, types.FunctionMetadataV4{Name: "set_heap_pages", Args: []types.FunctionArgumentMetadata{types.FunctionArgumentMetadata{Name: "pages", Type: "u64"}}, Documentation: []types.Text{" Set the number of pages in the WebAssembly environment's heap.", "", " # <weight>", " - `O(1)`", " - 1 storage write.", " - Base Weight: 1.405 µs", " - 1 write to HEAP_PAGES", " # </weight>"}}, types.FunctionMetadataV4{Name: "set_code", Args: []types.FunctionArgumentMetadata{types.FunctionArgumentMetadata{Name: "code", Type: "Vec<u8>"}}, Documentation: []types.Text{" Set the new runtime code.", "", " # <weight>", " - `O(C + S)` where `C` length of `code` and `S` complexity of `can_set_code`", " - 1 storage write (codec `O(C)`).", " - 1 call to `can_set_code`: `O(S)` (calls `sp_io::misc::runtime_version` which is expensive).", " - 1 event.", " The weight of this function is dependent on the runtime, but generally this is very expensive.", " We will treat this as a full block.", " # </weight>"}}, types.FunctionMetadataV4{Name: "set_code_without_checks", Args: []types.FunctionArgumentMetadata{types.FunctionArgumentMetadata{Name: "code", Type: "Vec<u8>"}}, Documentation: []types.Text{" Set the new runtime code without doing any checks of the given `code`.", "", " # <weight>", " - `O(C)` where `C` length of `code`", " - 1 storage write (codec `O(C)`).", " - 1 event.", " The weight of this function is dependent on the runtime. We will treat this as a full block.", " # </weight>"}}, types.FunctionMetadataV4{Name: "set_changes_trie_config", Args: []types.FunctionArgumentMetadata{types.FunctionArgumentMetadata{Name: "changes_trie_config", Type: "Option<ChangesTrieConfiguration>"}}, Documentation: []types.Text{" Set the new changes trie configuration.", "", " # <weight>", " - `O(1)`", " - 1 storage write or delete (codec `O(1)`).", " - 1 call to `deposit_log`: Uses `append` API, so O(1)", " - Base Weight: 7.218 µs", " - DB Weight:", "     - Writes: Changes Trie, System Digest", " # </weight>"}}, types.FunctionMetadataV4{Name: "set_storage", Args: []types.FunctionArgumentMetadata{types.FunctionArgumentMetadata{Name: "items", Type: "Vec<KeyValue>"}}, Documentation: []types.Text{" Set some items of storage.", "", " # <weight>", " - `O(I)` where `I` length of `items`", " - `I` storage writes (`O(1)`).", " - Base Weight: 0.568 * i µs", " - Writes: Number of items", " # </weight>"}}, types.FunctionMetadataV4{Name: "kill_storage", Args: []types.FunctionArgumentMetadata{types.FunctionArgumentMetadata{Name: "keys", Type: "Vec<Key>"}}, Documentation: []types.Text{" Kill some items from storage.", "", " # <weight>", " - `O(IK)` where `I` length of `keys` and `K` length of one key", " - `I` storage deletions.", " - Base Weight: .378 * i µs", " - Writes: Number of items", " # </weight>"}}, types.FunctionMetadataV4{Name: "kill_prefix", Args: []types.FunctionArgumentMetadata{types.FunctionArgumentMetadata{Name: "prefix", Type: "Key"}, types.FunctionArgumentMetadata{Name: "_subkeys", Type: "u32"}}, Documentation: []types.Text{" Kill all storage items with a key that starts with the given prefix.", "", " **NOTE:** We rely on the Root origin to provide us the number of subkeys under", " the prefix we are removing to accurately calculate the weight of this function.", "", " # <weight>", " - `O(P)` where `P` amount of keys with prefix `prefix`", " - `P` storage deletions.", " - Base Weight: 0.834 * P µs", " - Writes: Number of subkeys + 1", " # </weight>"}}, types.FunctionMetadataV4{Name: "suicide", Args: []types.FunctionArgumentMetadata(nil), Documentation: []types.Text{" Kill the sending account, assuming there are no references outstanding and the composite", " data is equal to its default value.", "", " # <weight>", " - `O(1)`", " - 1 storage read and deletion.", " --------------------", " Base Weight: 8.626 µs", " No DB Read or Write operations because caller is already in overlay", " # </weight>"}}}, HasEvents: true, Events: []types.EventMetadataV4{types.EventMetadataV4{Name: "ExtrinsicSuccess", Args: []types.Type{"DispatchInfo"}, Documentation: []types.Text{" An extrinsic completed successfully."}}, types.EventMetadataV4{Name: "ExtrinsicFailed", Args: []types.Type{"DispatchError", "DispatchInfo"}, Documentation: []types.Text{" An extrinsic failed."}}, types.EventMetadataV4{Name: "CodeUpdated", Args: []types.Type(nil), Documentation: []types.Text{" `:code` was updated."}}, types.EventMetadataV4{Name: "NewAccount", Args: []types.Type{"AccountId"}, Documentation: []types.Text{" A new account was created."}}, types.EventMetadataV4{Name: "KilledAccount", Args: []types.Type{"AccountId"}, Documentation: []types.Text{" An account was reaped."}}}, Constants: []types.ModuleConstantMetadataV6{types.ModuleConstantMetadataV6{Name: "BlockHashCount", Type: "T::BlockNumber", Value: types.Bytes{0x60, 0x9, 0x0, 0x0}, Documentation: []types.Text{" The maximum number of blocks to allow in mortal eras."}}, types.ModuleConstantMetadataV6{Name: "MaximumBlockWeight", Type: "Weight", Value: types.Bytes{0x0, 0x20, 0x4a, 0xa9, 0xd1, 0x1, 0x0, 0x0}, Documentation: []types.Text{" The maximum weight of a block."}}, types.ModuleConstantMetadataV6{Name: "DbWeight", Type: "RuntimeDbWeight", Value: types.Bytes{0x40, 0x78, 0x7d, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0xe1, 0xf5, 0x5, 0x0, 0x0, 0x0, 0x0}, Documentation: []types.Text{" The weight of runtime database operations the runtime can invoke."}}, types.ModuleConstantMetadataV6{Name: "BlockExecutionWeight", Type: "Weight", Value: types.Bytes{0x0, 0xf2, 0x5, 0x2a, 0x1, 0x0, 0x0, 0x0}, Documentation: []types.Text{" The base weight of executing a block, independent of the transactions in the block."}}, types.ModuleConstantMetadataV6{Name: "ExtrinsicBaseWeight", Type: "Weight", Value: types.Bytes{0x40, 0x59, 0x73, 0x7, 0x0, 0x0, 0x0, 0x0}, Documentation: []types.Text{" The base weight of an Extrinsic in the block, independent of the of extrinsic being executed."}}, types.ModuleConstantMetadataV6{Name: "MaximumBlockLength", Type: "u32", Value: types.Bytes{0x0, 0x0, 0x50, 0x0}, Documentation: []types.Text{" The maximum length of a block (in bytes)."}}}, Errors: []types.ErrorMetadataV8{types.ErrorMetadataV8{Name: "InvalidSpecName", Documentation: []types.Text{" The name of specification does not match between the current runtime", " and the new runtime."}}, types.ErrorMetadataV8{Name: "SpecVersionNeedsToIncrease", Documentation: []types.Text{" The specification version is not allowed to decrease between the current runtime", " and the new runtime."}}, types.ErrorMetadataV8{Name: "FailedToExtractRuntimeVersion", Documentation: []types.Text{" Failed to extract the runtime version from the new runtime.", "", " Either calling `Core_version` or decoding `RuntimeVersion` failed."}}, types.ErrorMetadataV8{Name: "NonDefaultComposite", Documentation: []types.Text{" Suicide called when the account has non-default composite data."}}, types.ErrorMetadataV8{Name: "NonZeroRefCount", Documentation: []types.Text{" There is a non-zero reference count preventing the account from being purged."}}}}, types.ModuleMetadataV10{Name: "RandomnessCollectiveFlip", HasStorage: true, Storage: types.StorageMetadataV10{Prefix: "RandomnessCollectiveFlip", Items: []types.StorageFunctionMetadataV10{types.StorageFunctionMetadataV10{Name: "RandomMaterial", Modifier: types.StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: types.StorageFunctionTypeV10{IsType: true, AsType: "Vec<T::Hash>", IsMap: false, AsMap: types.MapTypeV10{Hasher: types.StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: types.DoubleMapTypeV10{Hasher: types.StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: types.StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: types.Bytes{0x0}, Documentation: []types.Text{" Series of block headers from the last 81 blocks that acts as random seed material. This", " is arranged as a ring buffer with `block_number % 81` being the index into the `Vec` of", " the oldest hash."}}}}, HasCalls: true, Calls: []types.FunctionMetadataV4(nil), HasEvents: false, Events: []types.EventMetadataV4(nil), Constants: []types.ModuleConstantMetadataV6(nil), Errors: []types.ErrorMetadataV8(nil)}, types.ModuleMetadataV10{Name: "Timestamp", HasStorage: true, Storage: types.StorageMetadataV10{Prefix: "Timestamp", Items: []types.StorageFunctionMetadataV10{types.StorageFunctionMetadataV10{Name: "Now", Modifier: types.StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: types.StorageFunctionTypeV10{IsType: true, AsType: "T::Moment", IsMap: false, AsMap: types.MapTypeV10{Hasher: types.StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: types.DoubleMapTypeV10{Hasher: types.StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: types.StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: types.Bytes{0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}, Documentation: []types.Text{" Current time for the current block."}}, types.StorageFunctionMetadataV10{Name: "DidUpdate", Modifier: types.StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: types.StorageFunctionTypeV10{IsType: true, AsType: "bool", IsMap: false, AsMap: types.MapTypeV10{Hasher: types.StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: types.DoubleMapTypeV10{Hasher: types.StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: types.StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: types.Bytes{0x0}, Documentation: []types.Text{" Did the timestamp get updated in this block?"}}}}, HasCalls: true, Calls: []types.FunctionMetadataV4{types.FunctionMetadataV4{Name: "set", Args: []types.FunctionArgumentMetadata{types.FunctionArgumentMetadata{Name: "now", Type: "Compact<T::Moment>"}}, Documentation: []types.Text{" Set the current time.", "", " This call should be invoked exactly once per block. It will panic at the finalization", " phase, if this call hasn't been invoked by that time.", "", " The timestamp should be greater than the previous one by the amount specified by", " `MinimumPeriod`.", "", " The dispatch origin for this call must be `Inherent`.", "", " # <weight>", " - `O(T)` where `T` complexity of `on_timestamp_set`", " - 1 storage read and 1 storage mutation (codec `O(1)`). (because of `DidUpdate::take` in `on_finalize`)", " - 1 event handler `on_timestamp_set` `O(T)`.", " - Benchmark: 7.678 (min squares analysis)", "   - NOTE: This benchmark was done for a runtime with insignificant `on_timestamp_set` handlers.", "     New benchmarking is needed when adding new handlers.", " # </weight>"}}}, HasEvents: false, Events: []types.EventMetadataV4(nil), Constants: []types.ModuleConstantMetadataV6{types.ModuleConstantMetadataV6{Name: "MinimumPeriod", Type: "T::Moment", Value: types.Bytes{0xb8, 0xb, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}, Documentation: []types.Text{" The minimum period between blocks. Beware that this is different to the *expected* period", " that the block production apparatus provides. Your chosen consensus system will generally", " work with this to determine a sensible block time. e.g. For Aura, it will be double this", " period on default settings."}}}, Errors: []types.ErrorMetadataV8(nil)}, types.ModuleMetadataV10{Name: "Aura", HasStorage: false, Storage: types.StorageMetadataV10{Prefix: "", Items: []types.StorageFunctionMetadataV10(nil)}, HasCalls: false, Calls: []types.FunctionMetadataV4(nil), HasEvents: false, Events: []types.EventMetadataV4(nil), Constants: []types.ModuleConstantMetadataV6(nil), Errors: []types.ErrorMetadataV8(nil)}, types.ModuleMetadataV10{Name: "Grandpa", HasStorage: true, Storage: types.StorageMetadataV10{Prefix: "GrandpaFinality", Items: []types.StorageFunctionMetadataV10{types.StorageFunctionMetadataV10{Name: "State", Modifier: types.StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: types.StorageFunctionTypeV10{IsType: true, AsType: "StoredState<T::BlockNumber>", IsMap: false, AsMap: types.MapTypeV10{Hasher: types.StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: types.DoubleMapTypeV10{Hasher: types.StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: types.StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: types.Bytes{0x0}, Documentation: []types.Text{" State of the current authority set."}}, types.StorageFunctionMetadataV10{Name: "PendingChange", Modifier: types.StorageFunctionModifierV0{IsOptional: true, IsDefault: false, IsRequired: false}, Type: types.StorageFunctionTypeV10{IsType: true, AsType: "StoredPendingChange<T::BlockNumber>", IsMap: false, AsMap: types.MapTypeV10{Hasher: types.StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: types.DoubleMapTypeV10{Hasher: types.StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: types.StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: types.Bytes{0x0}, Documentation: []types.Text{" Pending change: (signaled at, scheduled change)."}}, types.StorageFunctionMetadataV10{Name: "NextForced", Modifier: types.StorageFunctionModifierV0{IsOptional: true, IsDefault: false, IsRequired: false}, Type: types.StorageFunctionTypeV10{IsType: true, AsType: "T::BlockNumber", IsMap: false, AsMap: types.MapTypeV10{Hasher: types.StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: types.DoubleMapTypeV10{Hasher: types.StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: types.StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: types.Bytes{0x0}, Documentation: []types.Text{" next block number where we can force a change."}}, types.StorageFunctionMetadataV10{Name: "Stalled", Modifier: types.StorageFunctionModifierV0{IsOptional: true, IsDefault: false, IsRequired: false}, Type: types.StorageFunctionTypeV10{IsType: true, AsType: "(T::BlockNumber, T::BlockNumber)", IsMap: false, AsMap: types.MapTypeV10{Hasher: types.StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: types.DoubleMapTypeV10{Hasher: types.StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: types.StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: types.Bytes{0x0}, Documentation: []types.Text{" `true` if we are currently stalled."}}, types.StorageFunctionMetadataV10{Name: "CurrentSetId", Modifier: types.StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: types.StorageFunctionTypeV10{IsType: true, AsType: "SetId", IsMap: false, AsMap: types.MapTypeV10{Hasher: types.StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: types.DoubleMapTypeV10{Hasher: types.StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: types.StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: types.Bytes{0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}, Documentation: []types.Text{" The number of changes (both in terms of keys and underlying economic responsibilities)", " in the \"set\" of Grandpa validators from genesis."}}, types.StorageFunctionMetadataV10{Name: "SetIdSession", Modifier: types.StorageFunctionModifierV0{IsOptional: true, IsDefault: false, IsRequired: false}, Type: types.StorageFunctionTypeV10{IsType: false, AsType: "", IsMap: true, AsMap: types.MapTypeV10{Hasher: types.StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: true}, Key: "SetId", Value: "SessionIndex", Linked: false}, IsDoubleMap: false, AsDoubleMap: types.DoubleMapTypeV10{Hasher: types.StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: types.StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: types.Bytes{0x0}, Documentation: []types.Text{" A mapping from grandpa set ID to the index of the *most recent* session for which its", " members were responsible.", "", " TWOX-NOTE: `SetId` is not under user control."}}}}, HasCalls: true, Calls: []types.FunctionMetadataV4{types.FunctionMetadataV4{Name: "report_equivocation", Args: []types.FunctionArgumentMetadata{types.FunctionArgumentMetadata{Name: "equivocation_proof", Type: "EquivocationProof<T::Hash, T::BlockNumber>"}, types.FunctionArgumentMetadata{Name: "key_owner_proof", Type: "T::KeyOwnerProof"}}, Documentation: []types.Text{" Report voter equivocation/misbehavior. This method will verify the", " equivocation proof and validate the given key ownership proof", " against the extracted offender. If both are valid, the offence", " will be reported.", "", " Since the weight of the extrinsic is 0, in order to avoid DoS by", " submission of invalid equivocation reports, a mandatory pre-validation of", " the extrinsic is implemented in a `SignedExtension`."}}}, HasEvents: true, Events: []types.EventMetadataV4{types.EventMetadataV4{Name: "NewAuthorities", Args: []types.Type{"AuthorityList"}, Documentation: []types.Text{" New authority set has been applied."}}, types.EventMetadataV4{Name: "Paused", Args: []types.Type(nil), Documentation: []types.Text{" Current authority set has been paused."}}, types.EventMetadataV4{Name: "Resumed", Args: []types.Type(nil), Documentation: []types.Text{" Current authority set has been resumed."}}}, Constants: []types.ModuleConstantMetadataV6(nil), Errors: []types.ErrorMetadataV8{types.ErrorMetadataV8{Name: "PauseFailed", Documentation: []types.Text{" Attempt to signal GRANDPA pause when the authority set isn't live", " (either paused or already pending pause)."}}, types.ErrorMetadataV8{Name: "ResumeFailed", Documentation: []types.Text{" Attempt to signal GRANDPA resume when the authority set isn't paused", " (either live or already pending resume)."}}, types.ErrorMetadataV8{Name: "ChangePending", Documentation: []types.Text{" Attempt to signal GRANDPA change with one already pending."}}, types.ErrorMetadataV8{Name: "TooSoon", Documentation: []types.Text{" Cannot signal forced change so soon after last."}}, types.ErrorMetadataV8{Name: "InvalidKeyOwnershipProof", Documentation: []types.Text{" A key ownership proof provided as part of an equivocation report is invalid."}}, types.ErrorMetadataV8{Name: "DuplicateOffenceReport", Documentation: []types.Text{" A given equivocation report is valid but already previously reported."}}}}, types.ModuleMetadataV10{Name: "Balances", HasStorage: true, Storage: types.StorageMetadataV10{Prefix: "Balances", Items: []types.StorageFunctionMetadataV10{types.StorageFunctionMetadataV10{Name: "TotalIssuance", Modifier: types.StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: types.StorageFunctionTypeV10{IsType: true, AsType: "T::Balance", IsMap: false, AsMap: types.MapTypeV10{Hasher: types.StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: types.DoubleMapTypeV10{Hasher: types.StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: types.StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: types.Bytes{0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}, Documentation: []types.Text{" The total units issued in the system."}}, types.StorageFunctionMetadataV10{Name: "Account", Modifier: types.StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: types.StorageFunctionTypeV10{IsType: false, AsType: "", IsMap: true, AsMap: types.MapTypeV10{Hasher: types.StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: true, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "T::AccountId", Value: "AccountData<T::Balance>", Linked: false}, IsDoubleMap: false, AsDoubleMap: types.DoubleMapTypeV10{Hasher: types.StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: types.StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: types.Bytes{0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}, Documentation: []types.Text{" The balance of an account.", "", " NOTE: This is only used in the case that this module is used to store balances."}}, types.StorageFunctionMetadataV10{Name: "Locks", Modifier: types.StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: types.StorageFunctionTypeV10{IsType: false, AsType: "", IsMap: true, AsMap: types.MapTypeV10{Hasher: types.StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: true, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "T::AccountId", Value: "Vec<BalanceLock<T::Balance>>", Linked: false}, IsDoubleMap: false, AsDoubleMap: types.DoubleMapTypeV10{Hasher: types.StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: types.StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: types.Bytes{0x0}, Documentation: []types.Text{" Any liquidity locks on some account balances.", " NOTE: Should only be accessed when setting, changing and freeing a lock."}}, types.StorageFunctionMetadataV10{Name: "StorageVersion", Modifier: types.StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: types.StorageFunctionTypeV10{IsType: true, AsType: "Releases", IsMap: false, AsMap: types.MapTypeV10{Hasher: types.StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: types.DoubleMapTypeV10{Hasher: types.StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: types.StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: types.Bytes{0x0}, Documentation: []types.Text{" Storage version of the pallet.", "", " This is set to v2.0.0 for new networks."}}}}, HasCalls: true, Calls: []types.FunctionMetadataV4{types.FunctionMetadataV4{Name: "transfer", Args: []types.FunctionArgumentMetadata{types.FunctionArgumentMetadata{Name: "dest", Type: "<T::Lookup as StaticLookup>::Source"}, types.FunctionArgumentMetadata{Name: "value", Type: "Compact<T::Balance>"}}, Documentation: []types.Text{" Transfer some liquid free balance to another account.", "", " `transfer` will set the `FreeBalance` of the sender and receiver.", " It will decrease the total issuance of the system by the `TransferFee`.", " If the sender's account is below the existential deposit as a result", " of the transfer, the account will be reaped.", "", " The dispatch origin for this call must be `Signed` by the transactor.", "", " # <weight>", " - Dependent on arguments but not critical, given proper implementations for", "   input config types. See related functions below.", " - It contains a limited number of reads and writes internally and no complex computation.", "", " Related functions:", "", "   - `ensure_can_withdraw` is always called internally but has a bounded complexity.", "   - Transferring balances to accounts that did not exist before will cause", "      `T::OnNewAccount::on_new_account` to be called.", "   - Removing enough funds from an account will trigger `T::DustRemoval::on_unbalanced`.", "   - `transfer_keep_alive` works the same way as `transfer`, but has an additional", "     check that the transfer will not kill the origin account.", " ---------------------------------", " - Base Weight: 73.64 µs, worst case scenario (account created, account removed)", " - DB Weight: 1 Read and 1 Write to destination account", " - Origin account is already in memory, so no DB operations for them.", " # </weight>"}}, types.FunctionMetadataV4{Name: "set_balance", Args: []types.FunctionArgumentMetadata{types.FunctionArgumentMetadata{Name: "who", Type: "<T::Lookup as StaticLookup>::Source"}, types.FunctionArgumentMetadata{Name: "new_free", Type: "Compact<T::Balance>"}, types.FunctionArgumentMetadata{Name: "new_reserved", Type: "Compact<T::Balance>"}}, Documentation: []types.Text{" Set the balances of a given account.", "", " This will alter `FreeBalance` and `ReservedBalance` in storage. it will", " also decrease the total issuance of the system (`TotalIssuance`).", " If the new free or reserved balance is below the existential deposit,", " it will reset the account nonce (`frame_system::AccountNonce`).", "", " The dispatch origin for this call is `root`.", "", " # <weight>", " - Independent of the arguments.", " - Contains a limited number of reads and writes.", " ---------------------", " - Base Weight:", "     - Creating: 27.56 µs", "     - Killing: 35.11 µs", " - DB Weight: 1 Read, 1 Write to `who`", " # </weight>"}}, types.FunctionMetadataV4{Name: "force_transfer", Args: []types.FunctionArgumentMetadata{types.FunctionArgumentMetadata{Name: "source", Type: "<T::Lookup as StaticLookup>::Source"}, types.FunctionArgumentMetadata{Name: "dest", Type: "<T::Lookup as StaticLookup>::Source"}, types.FunctionArgumentMetadata{Name: "value", Type: "Compact<T::Balance>"}}, Documentation: []types.Text{" Exactly as `transfer`, except the origin must be root and the source account may be", " specified.", " # <weight>", " - Same as transfer, but additional read and write because the source account is", "   not assumed to be in the overlay.", " # </weight>"}}, types.FunctionMetadataV4{Name: "transfer_keep_alive", Args: []types.FunctionArgumentMetadata{types.FunctionArgumentMetadata{Name: "dest", Type: "<T::Lookup as StaticLookup>::Source"}, types.FunctionArgumentMetadata{Name: "value", Type: "Compact<T::Balance>"}}, Documentation: []types.Text{" Same as the [`transfer`] call, but with a check that the transfer will not kill the", " origin account.", "", " 99% of the time you want [`transfer`] instead.", "", " [`transfer`]: struct.Module.html#method.transfer", " # <weight>", " - Cheaper than transfer because account cannot be killed.", " - Base Weight: 51.4 µs", " - DB Weight: 1 Read and 1 Write to dest (sender is in overlay already)", " #</weight>"}}}, HasEvents: true, Events: []types.EventMetadataV4{types.EventMetadataV4{Name: "Endowed", Args: []types.Type{"AccountId", "Balance"}, Documentation: []types.Text{" An account was created with some free balance."}}, types.EventMetadataV4{Name: "DustLost", Args: []types.Type{"AccountId", "Balance"}, Documentation: []types.Text{" An account was removed whose balance was non-zero but below ExistentialDeposit,", " resulting in an outright loss."}}, types.EventMetadataV4{Name: "Transfer", Args: []types.Type{"AccountId", "AccountId", "Balance"}, Documentation: []types.Text{" Transfer succeeded (from, to, value)."}}, types.EventMetadataV4{Name: "BalanceSet", Args: []types.Type{"AccountId", "Balance", "Balance"}, Documentation: []types.Text{" A balance was set by root (who, free, reserved)."}}, types.EventMetadataV4{Name: "Deposit", Args: []types.Type{"AccountId", "Balance"}, Documentation: []types.Text{" Some amount was deposited (e.g. for transaction fees)."}}, types.EventMetadataV4{Name: "Reserved", Args: []types.Type{"AccountId", "Balance"}, Documentation: []types.Text{" Some balance was reserved (moved from free to reserved)."}}, types.EventMetadataV4{Name: "Unreserved", Args: []types.Type{"AccountId", "Balance"}, Documentation: []types.Text{" Some balance was unreserved (moved from reserved to free)."}}, types.EventMetadataV4{Name: "ReserveRepatriated", Args: []types.Type{"AccountId", "AccountId", "Balance", "Status"}, Documentation: []types.Text{" Some balance was moved from the reserve of the first account to the second account.", " Final argument indicates the destination balance type."}}}, Constants: []types.ModuleConstantMetadataV6{types.ModuleConstantMetadataV6{Name: "ExistentialDeposit", Type: "T::Balance", Value: types.Bytes{0xf4, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}, Documentation: []types.Text{" The minimum amount required to keep an account open."}}}, Errors: []types.ErrorMetadataV8{types.ErrorMetadataV8{Name: "VestingBalance", Documentation: []types.Text{" Vesting balance too high to send value"}}, types.ErrorMetadataV8{Name: "LiquidityRestrictions", Documentation: []types.Text{" Account liquidity restrictions prevent withdrawal"}}, types.ErrorMetadataV8{Name: "Overflow", Documentation: []types.Text{" Got an overflow after adding"}}, types.ErrorMetadataV8{Name: "InsufficientBalance", Documentation: []types.Text{" Balance too low to send value"}}, types.ErrorMetadataV8{Name: "ExistentialDeposit", Documentation: []types.Text{" Value too low to create account due to existential deposit"}}, types.ErrorMetadataV8{Name: "KeepAlive", Documentation: []types.Text{" Transfer/payment would kill account"}}, types.ErrorMetadataV8{Name: "ExistingVestingSchedule", Documentation: []types.Text{" A vesting schedule already exists for this account"}}, types.ErrorMetadataV8{Name: "DeadAccount", Documentation: []types.Text{" Beneficiary account must pre-exist"}}}}, types.ModuleMetadataV10{Name: "TransactionPayment", HasStorage: true, Storage: types.StorageMetadataV10{Prefix: "TransactionPayment", Items: []types.StorageFunctionMetadataV10{types.StorageFunctionMetadataV10{Name: "NextFeeMultiplier", Modifier: types.StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: types.StorageFunctionTypeV10{IsType: true, AsType: "Multiplier", IsMap: false, AsMap: types.MapTypeV10{Hasher: types.StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: types.DoubleMapTypeV10{Hasher: types.StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: types.StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: types.Bytes{0x0, 0x0, 0x64, 0xa7, 0xb3, 0xb6, 0xe0, 0xd, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}, Documentation: []types.Text(nil)}, types.StorageFunctionMetadataV10{Name: "StorageVersion", Modifier: types.StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: types.StorageFunctionTypeV10{IsType: true, AsType: "Releases", IsMap: false, AsMap: types.MapTypeV10{Hasher: types.StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: types.DoubleMapTypeV10{Hasher: types.StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: types.StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: types.Bytes{0x0}, Documentation: []types.Text(nil)}}}, HasCalls: false, Calls: []types.FunctionMetadataV4(nil), HasEvents: false, Events: []types.EventMetadataV4(nil), Constants: []types.ModuleConstantMetadataV6{types.ModuleConstantMetadataV6{Name: "TransactionByteFee", Type: "BalanceOf<T>", Value: types.Bytes{0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}, Documentation: []types.Text{" The fee to be paid for making a transaction; the per-byte portion."}}, types.ModuleConstantMetadataV6{Name: "WeightToFee", Type: "Vec<WeightToFeeCoefficient<BalanceOf<T>>>", Value: types.Bytes{0x4, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1}, Documentation: []types.Text{" The polynomial that is applied in order to derive fee from weight."}}}, Errors: []types.ErrorMetadataV8(nil)}, types.ModuleMetadataV10{Name: "Scheduler", HasStorage: true, Storage: types.StorageMetadataV10{Prefix: "Scheduler", Items: []types.StorageFunctionMetadataV10{types.StorageFunctionMetadataV10{Name: "Agenda", Modifier: types.StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: types.StorageFunctionTypeV10{IsType: false, AsType: "", IsMap: true, AsMap: types.MapTypeV10{Hasher: types.StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: true}, Key: "T::BlockNumber", Value: "Vec<Option<Scheduled<<T as Trait>::Call, T::BlockNumber>>>", Linked: false}, IsDoubleMap: false, AsDoubleMap: types.DoubleMapTypeV10{Hasher: types.StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: types.StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: types.Bytes{0x0}, Documentation: []types.Text{" Items to be executed, indexed by the block number that they should be executed on."}}, types.StorageFunctionMetadataV10{Name: "Lookup", Modifier: types.StorageFunctionModifierV0{IsOptional: true, IsDefault: false, IsRequired: false}, Type: types.StorageFunctionTypeV10{IsType: false, AsType: "", IsMap: true, AsMap: types.MapTypeV10{Hasher: types.StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: true}, Key: "Vec<u8>", Value: "TaskAddress<T::BlockNumber>", Linked: false}, IsDoubleMap: false, AsDoubleMap: types.DoubleMapTypeV10{Hasher: types.StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: types.StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: types.Bytes{0x0}, Documentation: []types.Text{" Lookup from identity to the block number and index of the task."}}}}, HasCalls: true, Calls: []types.FunctionMetadataV4{types.FunctionMetadataV4{Name: "schedule", Args: []types.FunctionArgumentMetadata{types.FunctionArgumentMetadata{Name: "when", Type: "T::BlockNumber"}, types.FunctionArgumentMetadata{Name: "maybe_periodic", Type: "Option<schedule::Period<T::BlockNumber>>"}, types.FunctionArgumentMetadata{Name: "priority", Type: "schedule::Priority"}, types.FunctionArgumentMetadata{Name: "call", Type: "Box<<T as Trait>::Call>"}}, Documentation: []types.Text{" Anonymously schedule a task.", "", " # <weight>", " - S = Number of already scheduled calls", " - Base Weight: 22.29 + .126 * S µs", " - DB Weight:", "     - Read: Agenda", "     - Write: Agenda", " - Will use base weight of 25 which should be good for up to 30 scheduled calls", " # </weight>"}}, types.FunctionMetadataV4{Name: "cancel", Args: []types.FunctionArgumentMetadata{types.FunctionArgumentMetadata{Name: "when", Type: "T::BlockNumber"}, types.FunctionArgumentMetadata{Name: "index", Type: "u32"}}, Documentation: []types.Text{" Cancel an anonymously scheduled task.", "", " # <weight>", " - S = Number of already scheduled calls", " - Base Weight: 22.15 + 2.869 * S µs", " - DB Weight:", "     - Read: Agenda", "     - Write: Agenda, Lookup", " - Will use base weight of 100 which should be good for up to 30 scheduled calls", " # </weight>"}}, types.FunctionMetadataV4{Name: "schedule_named", Args: []types.FunctionArgumentMetadata{types.FunctionArgumentMetadata{Name: "id", Type: "Vec<u8>"}, types.FunctionArgumentMetadata{Name: "when", Type: "T::BlockNumber"}, types.FunctionArgumentMetadata{Name: "maybe_periodic", Type: "Option<schedule::Period<T::BlockNumber>>"}, types.FunctionArgumentMetadata{Name: "priority", Type: "schedule::Priority"}, types.FunctionArgumentMetadata{Name: "call", Type: "Box<<T as Trait>::Call>"}}, Documentation: []types.Text{" Schedule a named task.", "", " # <weight>", " - S = Number of already scheduled calls", " - Base Weight: 29.6 + .159 * S µs", " - DB Weight:", "     - Read: Agenda, Lookup", "     - Write: Agenda, Lookup", " - Will use base weight of 35 which should be good for more than 30 scheduled calls", " # </weight>"}}, types.FunctionMetadataV4{Name: "cancel_named", Args: []types.FunctionArgumentMetadata{types.FunctionArgumentMetadata{Name: "id", Type: "Vec<u8>"}}, Documentation: []types.Text{" Cancel a named scheduled task.", "", " # <weight>", " - S = Number of already scheduled calls", " - Base Weight: 24.91 + 2.907 * S µs", " - DB Weight:", "     - Read: Agenda, Lookup", "     - Write: Agenda, Lookup", " - Will use base weight of 100 which should be good for up to 30 scheduled calls", " # </weight>"}}}, HasEvents: true, Events: []types.EventMetadataV4{types.EventMetadataV4{Name: "Scheduled", Args: []types.Type{"BlockNumber", "u32"}, Documentation: []types.Text(nil)}, types.EventMetadataV4{Name: "Canceled", Args: []types.Type{"BlockNumber", "u32"}, Documentation: []types.Text(nil)}, types.EventMetadataV4{Name: "Dispatched", Args: []types.Type{"TaskAddress<BlockNumber>", "Option<Vec<u8>>", "DispatchResult"}, Documentation: []types.Text(nil)}}, Constants: []types.ModuleConstantMetadataV6(nil), Errors: []types.ErrorMetadataV8(nil)}, types.ModuleMetadataV10{Name: "Bridge", HasStorage: true, Storage: types.StorageMetadataV10{Prefix: "BridgeModule", Items: []types.StorageFunctionMetadataV10(nil)}, HasCalls: true, Calls: []types.FunctionMetadataV4{types.FunctionMetadataV4{Name: "submit", Args: []types.FunctionArgumentMetadata{types.FunctionArgumentMetadata{Name: "app_id", Type: "AppId"}, types.FunctionArgumentMetadata{Name: "message", Type: "Message"}}, Documentation: []types.Text{" Submit `message` for dispatch to an application identified by `app_id`."}}}, HasEvents: true, Events: []types.EventMetadataV4(nil), Constants: []types.ModuleConstantMetadataV6(nil), Errors: []types.ErrorMetadataV8{types.ErrorMetadataV8{Name: "HandlerNotFound", Documentation: []types.Text(nil)}}}, types.ModuleMetadataV10{Name: "Verifier", HasStorage: true, Storage: types.StorageMetadataV10{Prefix: "VerifierModule", Items: []types.StorageFunctionMetadataV10{types.StorageFunctionMetadataV10{Name: "RelayKey", Modifier: types.StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: types.StorageFunctionTypeV10{IsType: true, AsType: "T::AccountId", IsMap: false, AsMap: types.MapTypeV10{Hasher: types.StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: types.DoubleMapTypeV10{Hasher: types.StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: types.StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: types.Bytes{0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}, Documentation: []types.Text(nil)}, types.StorageFunctionMetadataV10{Name: "VerifiedPayloads", Modifier: types.StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: types.StorageFunctionTypeV10{IsType: false, AsType: "", IsMap: true, AsMap: types.MapTypeV10{Hasher: types.StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: true, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "T::Hash", Value: "()", Linked: false}, IsDoubleMap: false, AsDoubleMap: types.DoubleMapTypeV10{Hasher: types.StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: types.StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: types.Bytes(nil), Documentation: []types.Text(nil)}}}, HasCalls: true, Calls: []types.FunctionMetadataV4(nil), HasEvents: true, Events: []types.EventMetadataV4(nil), Constants: []types.ModuleConstantMetadataV6(nil), Errors: []types.ErrorMetadataV8{types.ErrorMetadataV8{Name: "NotSupported", Documentation: []types.Text(nil)}, types.ErrorMetadataV8{Name: "Invalid", Documentation: []types.Text(nil)}}}, types.ModuleMetadataV10{Name: "Asset", HasStorage: true, Storage: types.StorageMetadataV10{Prefix: "Asset", Items: []types.StorageFunctionMetadataV10{types.StorageFunctionMetadataV10{Name: "TotalIssuance", Modifier: types.StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: types.StorageFunctionTypeV10{IsType: false, AsType: "", IsMap: true, AsMap: types.MapTypeV10{Hasher: types.StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: true, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "AssetId", Value: "U256", Linked: false}, IsDoubleMap: false, AsDoubleMap: types.DoubleMapTypeV10{Hasher: types.StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: types.StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: types.Bytes{0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}, Documentation: []types.Text(nil)}, types.StorageFunctionMetadataV10{Name: "Account", Modifier: types.StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: types.StorageFunctionTypeV10{IsType: false, AsType: "", IsMap: false, AsMap: types.MapTypeV10{Hasher: types.StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: true, AsDoubleMap: types.DoubleMapTypeV10{Hasher: types.StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: true, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "AssetId", Key2: "T::AccountId", Value: "AccountData", Key2Hasher: types.StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: true, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: types.Bytes{0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}, Documentation: []types.Text(nil)}}}, HasCalls: true, Calls: []types.FunctionMetadataV4{types.FunctionMetadataV4{Name: "transfer", Args: []types.FunctionArgumentMetadata{types.FunctionArgumentMetadata{Name: "asset_id", Type: "H160"}, types.FunctionArgumentMetadata{Name: "to", Type: "T::AccountId"}, types.FunctionArgumentMetadata{Name: "amount", Type: "U256"}}, Documentation: []types.Text{" Transfer some free balance to another account."}}}, HasEvents: true, Events: []types.EventMetadataV4{types.EventMetadataV4{Name: "Burned", Args: []types.Type{"H160", "AccountId", "U256"}, Documentation: []types.Text(nil)}, types.EventMetadataV4{Name: "Minted", Args: []types.Type{"H160", "AccountId", "U256"}, Documentation: []types.Text(nil)}, types.EventMetadataV4{Name: "Transferred", Args: []types.Type{"H160", "AccountId", "AccountId", "U256"}, Documentation: []types.Text(nil)}}, Constants: []types.ModuleConstantMetadataV6(nil), Errors: []types.ErrorMetadataV8{types.ErrorMetadataV8{Name: "FreeTransferOverflow", Documentation: []types.Text{" Free balance got overflowed after transfer."}}, types.ErrorMetadataV8{Name: "TotalMintingOverflow", Documentation: []types.Text{" Total issuance got overflowed after minting."}}, types.ErrorMetadataV8{Name: "FreeMintingOverflow", Documentation: []types.Text{" Free balance got overflowed after minting."}}, types.ErrorMetadataV8{Name: "TotalBurningUnderflow", Documentation: []types.Text{" Total issuance got underflowed after burning."}}, types.ErrorMetadataV8{Name: "FreeBurningUnderflow", Documentation: []types.Text{" Free balance got underflowed after burning."}}, types.ErrorMetadataV8{Name: "InsufficientBalance", Documentation: []types.Text(nil)}}}, types.ModuleMetadataV10{Name: "ETH", HasStorage: true, Storage: types.StorageMetadataV10{Prefix: "Erc20Module", Items: []types.StorageFunctionMetadataV10(nil)}, HasCalls: true, Calls: []types.FunctionMetadataV4{types.FunctionMetadataV4{Name: "burn", Args: []types.FunctionArgumentMetadata{types.FunctionArgumentMetadata{Name: "recipient", Type: "H160"}, types.FunctionArgumentMetadata{Name: "amount", Type: "U256"}}, Documentation: []types.Text(nil)}}, HasEvents: true, Events: []types.EventMetadataV4{types.EventMetadataV4{Name: "Transfer", Args: []types.Type{"AccountId", "H160", "U256"}, Documentation: []types.Text(nil)}}, Constants: []types.ModuleConstantMetadataV6(nil), Errors: []types.ErrorMetadataV8(nil)}, types.ModuleMetadataV10{Name: "ERC20", HasStorage: true, Storage: types.StorageMetadataV10{Prefix: "Erc20Module", Items: []types.StorageFunctionMetadataV10(nil)}, HasCalls: true, Calls: []types.FunctionMetadataV4{types.FunctionMetadataV4{Name: "burn", Args: []types.FunctionArgumentMetadata{types.FunctionArgumentMetadata{Name: "token_id", Type: "H160"}, types.FunctionArgumentMetadata{Name: "recipient", Type: "H160"}, types.FunctionArgumentMetadata{Name: "amount", Type: "U256"}}, Documentation: []types.Text(nil)}}, HasEvents: true, Events: []types.EventMetadataV4{types.EventMetadataV4{Name: "Transfer", Args: []types.Type{"TokenId", "AccountId", "H160", "U256"}, Documentation: []types.Text(nil)}}, Constants: []types.ModuleConstantMetadataV6(nil), Errors: []types.ErrorMetadataV8{types.ErrorMetadataV8{Name: "InvalidTokenId", Documentation: []types.Text(nil)}}}}}, Extrinsic: types.ExtrinsicV11{Version: 0x4, SignedExtensions: []string{"CheckSpecVersion", "CheckTxVersion", "CheckGenesis", "CheckEra", "CheckNonce", "CheckWeight", "ChargeTransactionPayment"}}}}
